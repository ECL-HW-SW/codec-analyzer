import requests
import json
import ast


"""
A Class for handling all the HTTP requests to the Codec Analyzer Database.
It works by gathering the input in the form of a list and transforming it into a Python dict 
so that it can then be parsed as JSON and sent.
"""
class HttpContent:
    
    def __init__(self, base_url: str) -> None:
        self.base_url = base_url


    """
    Checks if there is an entry with the given parameters as columns in the Database
    
    @param str unique_config: unique configuration string to represent the codification process
    @param str commit_hash: the github commit hash for the codec
    @returns bool
    """
    def hasEntry(
        self, commitHash, uniqueVideoAttrs, uniqueConfigAttrs
    ) -> dict:
        url = f"{self.base_url}/encoding-results/has-entry/{uniqueVideoAttrs}/{uniqueConfigAttrs}/{commitHash}"
        response = requests.request("GET", url, headers={}, data={})
        return json.loads(response.content or 'null')

    # NOTE to self:
    # should the Codec class really be the one containing the Video and EncodingResult? 
    # would it not be better for them to be separate? Something to think about.

    """
    Saves the EncodingResult on the database, 
    mapping the entities with their respective Python classes in a 1:1 relationship.

    @params codec: Codec
    @params results: EncodingResult
    @returns requesst.Response 
    """
    def POST_encoding_result(self, codec, results) -> requests.Response: 
        video = codec.get_video()
        encoding_config = codec.get_encoding_config()

        payload = json.dumps({
            "codec": {
                "name": codec.get_codec(),
                "commitHash": codec.get_commit_hash(),
                "codecAttrs": codec.get_base_attrs(),
            },
            "video": {
                "name": video.get_name(),
                "resolution": video.get_resolution(),
                "fps": video.get_fps(),
                "nFrames": video.get_framesnumber(),
                "format": video.get_format(),
                "uniqueAttrs": video.get_unique_attrs() 
            },
            "encodingConfig": {
                "uniqueAttrs": encoding_config.get_unique_attrs(),
                "qp": encoding_config.qp,
                "nFrames": encoding_config.nFrames,
                "nThreads": encoding_config.nThreads,
                "codecAttrs": encoding_config.codecSetAttrs,
                "preset": encoding_config.preset
            },
            "ypsnr": results["ypsnr"],
            "upsnr": results["upsnr"],
            "vpsnr": results["vpsnr"],
            "yuvpsnr": results["yuvpsnr"],
            "bitrate": results["bitrate"],
            "time": results["time"],
            "energyConsumption": results["energyConsumption"] 
        })

        headers = {'Content-Type': 'application/json'}
        response = requests.request("POST", f"{self.base_url}/encoding-results", headers=headers, data=payload)
        return response


    """
    Gets all the saved EncodingResults from the Database and returns them in the form of of a list

    @returns list of all available EncodingResults
    """
    def GET_all_encoding_results(self) -> list:
        response = requests.get(self.base_url)
        return ast.literal_eval(response.text)
    

    """
    Deletes an EncodingResult from the Database. 
    This should only be done in case of a wrong configuration, or something of the sort,
    so that the data goes unaldutered. 

    @param id: the specific EncoidngResult ID, generated by the server
    @returns requests.Response
    """
    def DELETE_encoding_result(self, id: str) -> requests.Response:
        url = self.base_url + f"/{id}"
        headers = {'Content-Type': 'application/json'}
        response = requests.request("DELETE", url, headers=headers)
        return response
    

    """
    GETTERS AND SETTERS BELOW
    """


    def set_base_url(self, base_url: str) -> None:
        self.base_url = base_url


    def get_base_url(self) -> str:
        return self.base_url